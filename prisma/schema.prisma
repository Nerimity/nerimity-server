generator client {
  provider = "prisma-client-js"
  previewFeatures = []
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id              String  @id
  email           String  @unique
  password        String
  passwordVersion Int     @default(1)
  userId          String  @unique
  user            User    @relation(fields: [userId], references: [id])
  suspendCount    Int     @default(0) // How many times the user has been suspended.
  postNotificationCount  Int                     @default(0)
  serverOrderIds   String[]
  dmStatus               Int                     @default(0)

  FCMTokens        FirebaseMessagingToken[]

  emailConfirmed  Boolean @default(false)
  emailConfirmCode String?
}


// make a model to store all the ips that have been banned. it will also have an expire date
model BannedIp {
  id String @id
  ipAddress String @unique
  expireAt  DateTime
}

model FirebaseMessagingToken {
  token String @unique
  accountId String
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model User {
  id                     String                  @id
  badges                 Int                     @default(0)
  username               String
  tag                    String
  avatar                 String?
  banner                 String?
  status                 Int
  customStatus           String?
  hexColor               String?
  bot                    Boolean?
  joinedAt               DateTime                @default(now())
  account                Account?
  channelsCreatedByMe    Channel[]
  recipientFriends       Friend[]                @relation("recipient_friends")
  friends                Friend[]                @relation("friends")
  inbox                  Inbox[]                 @relation("inbox")
  recipientInbox         Inbox[]                 @relation("recipient_inbox")
  messages               Message[]
  sendMessageMentions    MessageMention[]        @relation("sent_message_mentions")
  messageMentions        MessageMention[]        @relation("message_mentions")
  serversCreatedByMe     Server[]                @relation("server_creator")
  lastSeenServerChannels ServerChannelLastSeen[]
  createdServerInvites   ServerInvite[]
  memberInServers        ServerMember[]
  servers                Server[]
  createdServerRoles     ServerRole[]
  bannedServers          BannedServerMember[]
  customEmojis           CustomEmoji[]

  reactedMessageEmojis   MessageReaction[]

  joinedServerSettings ServerMemberSettings[] 


  posts                  Post[]
  likedPosts             PostLike[]
  followers              Follower[]
  following              Follower[]              @relation(name: "following")
  postNotifications      PostNotification[]      @relation(name: "postNotifications")
  sentPostNotifications  PostNotification[]
  mentionedMessages      Message[]               @relation(name: "mentioned_messages")

  profile                UserProfile?

  notifications         UserNotification[]
  suspension            Suspension?

  devices               UserDevice[]

  connections           UserConnection[]
  notice ChatNotice?

  auditActions          AuditLog[]

  openedTickets         Ticket[]
}

model UserConnection {
  id String @id
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  public Boolean
  provider String
  refreshToken String
  connectedAt DateTime @default(now())
}

// Used for ip banning.
// In the future, account owners to see whos logged in to your account.
model UserDevice {
  id          String    @id
  userId      String
  ipAddress   String

  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  lastSeenAt  DateTime @default(now())

  @@index([userId, ipAddress])
}


model UserNotification {
  id             String @id
  userId         String

  messageId      String?
  serverId       String?

  user           User     @relation(fields: [userId], references: [id])
  message        Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  server         Server? @relation(fields: [serverId], references: [id], onDelete: Cascade)
  serverMember   ServerMember? @relation(fields: [userId, serverId], references: [userId, serverId], onDelete: Cascade)

  createdAt               DateTime                @default(now())
}

model UserProfile {
  userId    String   @id
  user      User @relation(fields: [userId], references: [id])
  bio       String?
  pronouns  String? @default("rather not say")
}

model Follower {
  id            String   @id
  followedById  String
  followedBy    User     @relation(fields: [followedById], references: [id], name: "following")

  followedToId  String
  followedTo    User     @relation(fields: [followedToId], references: [id])
  @@unique([followedById, followedToId])
}



model Suspension {
  id            String    @id
  suspendedAt   DateTime  @default(now())
  expireAt      DateTime?
  reason        String?
  suspendedById String
  userId        String       @unique
  user          User         @relation(fields: [userId], references: [id])
}

model Server {
  id                     String                  @id
  name                   String
  avatar                 String?
  banner                 String?
  hexColor               String
  defaultChannelId       String
  systemChannelId        String? @unique // Used for system messages eg member joined message. 
  defaultRoleId          String


  systemChannel          Channel?                @relation("systemChannel", fields: [systemChannelId], references: [id], onDelete: SetNull)

  createdById            String

  createdAt              DateTime                @default(now())
  createdBy              User                    @relation("server_creator", fields: [createdById], references: [id])
  channels               Channel[]
  messageMentions        MessageMention[]
  lastSeenChannelMembers ServerChannelLastSeen[]
  invites                ServerInvite[]
  serverMembers          ServerMember[]
  users                  User[]
  roles                  ServerRole[]
  bannedUsers            BannedServerMember[]
  verified               Boolean                @default(false)

  // oops, it should be camel cased. 
  PublicServer           PublicServer?

  attachments Attachment[]


  customEmojis CustomEmoji[]

  memberSettings ServerMemberSettings[]
  memberNotifications         UserNotification[]


}

// Personal settings for joined servers
model ServerMemberSettings {
  id String @id

  serverId String
  userId   String

  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  notificationSoundMode Int @default(0)
  notificationPingMode Int @default(0) // The red pill alert thing.


  @@unique([userId, serverId])
}



model CustomEmoji {
  id           String  @id
  name         String
  gif          Boolean

  serverId     String
  server       Server  @relation(fields: [serverId], references: [id], onDelete: Cascade)

  uploadedById String 
  uploadedBy   User    @relation(fields: [uploadedById], references: [id], onDelete: Cascade) 
}


model PublicServer {
  id              String    @id
  serverId        String    @unique
  server          Server    @relation(fields: [serverId], references: [id], onDelete: Cascade) 
  description     String

  bumpCount       Int       @default(1)
  bumpedAt        DateTime  @default(now())

  lifetimeBumpCount   Int   @default(1)

  createdAt       DateTime   @default(now())
}

model ServerRole {
  id                     String                  @id
  name                   String
  hexColor               String

  createdById            String
  createdBy              User                    @relation(fields: [createdById], references: [id])

  hideRole               Boolean                 @default(false)

  permissions            Int

  serverId               String
  server                 Server                  @relation(fields: [serverId], references: [id], onDelete: Cascade)
  order                  Int

  botRole     Boolean?

  createdAt              DateTime                @default(now())

}

model ServerInvite {
  id          String   @id
  code        String
  isCustom    Boolean
  uses        Int      @default(0)
  serverId    String
  createdById String
  createdAt   DateTime @default(now())
  createdBy   User     @relation(fields: [createdById], references: [id])
  server      Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
}

model ServerMember {
  id       String   @id
  serverId String
  userId   String
  joinedAt DateTime @default(now())
  server   Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  roleIds  String[]

  notifications         UserNotification[]
  @@unique([userId, serverId])

}


model BannedServerMember {
  id       String  @id
  userId   String
  serverId String
  server   Server  @relation(fields: [serverId], references: [id], onDelete: Cascade)
  user     User  @relation(fields: [userId], references: [id])
}

model Friend {
  id          String   @id
  status      Int
  userId      String 
  recipientId String
  createdAt   DateTime @default(now())
  recipient   User     @relation("recipient_friends", fields: [recipientId], references: [id])
  user        User     @relation("friends", fields: [userId], references: [id])

  @@unique([userId, recipientId])
}

model Channel {
  id                     String                  @id
  name                   String?
  icon                   String?
  serverId               String?
  createdById            String?
  type                   Int
  
  categoryId             String?
  category               Channel?                @relation(fields: [categoryId], references: [id], name: "channel_categories", onDelete: SetNull)

  permissions            Int?
  lastMessagedAt         DateTime?
  createdAt              DateTime                @default(now())
  createdBy              User?                   @relation(fields: [createdById], references: [id])
  server                 Server?                 @relation(fields: [serverId], references: [id], onDelete: SetNull)
  inbox                  Inbox[]
  messages               Message[]
  messageMentions        MessageMention[]
  lastSeenChannelServers ServerChannelLastSeen[]
  attachments            Attachment[]
  order                  Int?

  categories             Channel[] @relation(name: "channel_categories")


  // when this channel is scheduled to delete.
  deleting               Boolean?

  systemChannelServer    Server?  @relation("systemChannel")

  notice ChatNotice?
  ticket Ticket?
}

model Ticket {
  id          Int   @id @default(autoincrement())
  title       String
  category    Int
  status      Int      @default(2)
  channelId   String   @unique
  channel     Channel  @relation(fields: [channelId], references: [id])

  lastUpdatedAt DateTime @default(now())

  openedById  String
  openedBy    User     @relation(fields: [openedById], references: [id])
  openedAt    DateTime @default(now())
  seen        Boolean? @default(true)
}

model Inbox {
  id          String   @id
  createdById String
  recipientId String
  channelId   String
  closed      Boolean
  createdAt   DateTime @default(now())
  channel     Channel  @relation(fields: [channelId], references: [id])
  createdBy   User     @relation("inbox", fields: [createdById], references: [id])
  recipient   User     @relation("recipient_inbox", fields: [recipientId], references: [id])
  lastSeen    DateTime?

  @@unique([createdById, channelId])
}

model Message {
  id          String   @id
  content     String
  type        Int
  channelId   String
  createdById String
  editedAt    DateTime?
  createdAt   DateTime @default(now())
  channel     Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  createdBy   User     @relation(fields: [createdById], references: [id])
  mentions    User[]  @relation(name: "mentioned_messages")

  attachments Attachment[]
  reactions   MessageReaction[]

  quotedMessages Message[] @relation(name: "quoted_messages")
  quotedInMessages Message[] @relation(name: "quoted_messages")

  embed Json?

  notifications         UserNotification[]

  @@index([channelId])
}

// When deleting a channel or a server, we will delete 1000 messages every 1 minute
// To not cause strain to the server.
model ScheduleMessageDelete {
  channelId           String   @id
  deletingMessages    Boolean  @default(true)
  deletingAttachments Boolean  @default(true)
  scheduledAt         DateTime @default(now())
}

model MessageReaction {
  id  String   @id
  name  String
  emojiId String?
  gif     Boolean?

  reactedUsers User[]

  messageId    String
  message      Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
}



model MessageMention {
  id            String   @id
  mentionedById String
  mentionedToId String
  channelId     String
  serverId      String?
  count         Int      @default(0)
  createdAt     DateTime @default(now())
  channel       Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  mentionedBy   User     @relation("sent_message_mentions", fields: [mentionedById], references: [id])
  mentionedTo   User     @relation("message_mentions", fields: [mentionedToId], references: [id])
  server        Server?  @relation(fields: [serverId], references: [id], onDelete: Cascade)


  @@unique([mentionedById, mentionedToId, channelId])

}

model Attachment {
  id          String @id
  
  provider    String @default("local")
  fileId     String?
  mime        String?


  path        String?
  width       Int?
  height      Int?

  messageId   String?
  message     Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)

  postId String?
  post   Post? @relation(fields: [postId], references: [id], onDelete: Cascade)

  channelId String?
  channel   Channel? @relation(fields: [channelId], references: [id], onDelete: Cascade)

  serverId String?
  server   Server? @relation(fields: [serverId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
}

model ServerChannelLastSeen {
  id        String   @id
  userId    String
  serverId  String
  channelId String
  lastSeen  DateTime
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  server    Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@unique([channelId, userId, serverId])
}


model Post {
  id          String   @id
  createdById String
  createdBy   User @relation(fields: [createdById], references: [id])
  content     String?
  createdAt   DateTime @default(now())
  editedAt    DateTime?


  quotedPostId    String?
  quotedPost      Post? @relation(fields: [quotedPostId], references: [id], name: "quotedPost")
  
  quotes     Post[] @relation(name: "quotedPost")

  likedBy    PostLike[]



  commentToId  String?
  commentTo  Post? @relation(fields: [commentToId], references: [id], name: "commentTo", onDelete: SetNull)

  comments Post[] @relation(name: "commentTo")
  attachments Attachment[]


  notifications PostNotification[]
  deleted Boolean?
}

model PostNotification {
  id          String   @id
  createdAt   DateTime @default(now())
  type        Int

  toId        String
  to          User     @relation(fields: [toId], references: [id], name: "postNotifications", onDelete: Cascade)

  byId        String
  by          User     @relation(fields: [byId], references: [id], onDelete: Cascade)

  postId      String?
  post        Post?     @relation(fields: [postId], references: [id])
}


model PostLike {
  id            String   @id
  
  postId        String
  post          Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  likedById     String
  likedBy       User @relation(fields: [likedById], references: [id])
  createdAt   DateTime @default(now())

  @@unique([postId, likedById])
}

model ChatNotice {
  id          String   @id
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  // For server channels
  channelId   String? @unique
  channel     Channel? @relation(fields: [channelId], references: [id], onDelete: Cascade)

  // For dms
  userId      String? @unique
  user        User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  content     String
}


model AuditLog {
  id          String   @id
  createdAt   DateTime @default(now())

  actionById   String
  actionBy     User     @relation(fields: [actionById], references: [id])
  actionType   Int



  serverName   String? 
  serverId     String?

  channelId    String?
  channelName  String?

  userId       String?
  username     String?
  
  ipAddress    String?
  reason       String?
  expireAt     DateTime?
}